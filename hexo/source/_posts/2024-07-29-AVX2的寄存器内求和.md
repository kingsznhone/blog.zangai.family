---
title: AVX2的寄存器内求和
date: 2024-07-29 01:33:56
tags:
  - C++
cover: /img/8DAC22EA.jpg
---

# SSE时代
在宽度为128bit的SSE指令集中，使用两次`__m128 _mm_hadd_ps (__m128 a, __m128 b)`，就能将寄存器里的4个浮点数相加求和

假设目前XMM寄存器里存储着四个浮点数
| | | | |
|-|-|-|-|
|f3|f2|f1|f0|

一次`hadd_ps(xmm0,xmm0)`以后，结果为

|   |   |   |   |
|---|---|---|---|
|f2+f3|f0+f1|f2+f3|f0+f1|

第二次`hadd_ps(xmm0,xmm0)`以后，结果为
|   |   |   |   |
|---|---|---|---|
|f0+f1+f2+f3|f0+f1+f2+f3|f0+f1+f2+f3|f0+f1+f2+f3|

现在四个数据槽的位置都是a+b+c+d了，随便取一个出来就是四个数的和，

这个求和只用到了两个汇编指令，并且没有访存开销。

相比`sum=data[0]+data[1]+data[2]+data[3]`，4次加法指令四次访存，不知道高到哪里去了

# AVX2时代

这个方法在AVX2时代出问题了，AVX2的256bit宽度，其实是两个128bit拼起来的，就类似于在高架桥下面又修了一条地面辅路，堪称一个赛博凑合。

这就导致很多从SSE指令集中继承下来的指令，在AVX2中出现奇怪的表现

所以SSE的寄存器内求和方法也失效了

假设YMM0中的数据存储如下

| | | | | | | | |
|-|-|-|-|-|-|-|-|
|f7|f6|f5|f4|f3|f2|f1|f0|

执行`_mm256_hadd_ps(ymm0,ymm0)`以后，存储结构变成了如下

| | | | | | | | |
|-|-|-|-|-|-|-|-|
|f6+f7|f4+f5|f6+f7|f4+f5|f2+f3|f0+f1|f2+f3|f0+f1|

可以观察到，hadd像是在高128bit和低128bit分别执行了一样

再执行一次`_mm256_hadd_ps(ymm0,ymm0)`，得到结果

| | | | | | | | |
|-|-|-|-|-|-|-|-|
|f4+f5+f6+f7|f4+f5+f6+f7|f4+f5+f6+f7|f4+f5+f6+f7|f0+f1+f2+f3|f0+f1+f2+f3|f0+f1+f2+f3|f0+f1+f2+f3|

芜湖，YMM0现在变成了高低两部分的和，不能再像梦想中的那样再执行一次hadd了

事到如今，只能使用ymm0[0]+ymm[4]了吗？

这也可以是一个解决方法，毕竟只需要再做一次寄存器回写和一次浮点add。

不过我更喜欢直接在寄存器上解决，这个时候就要用到`_mm256_extractf128_ps`了，这个指令会把高128bit的数据提取到另一个YMM里，再对高128bit和低128bit求和，就得到了最终结果

那么最后的完整代码长这样
``` C
__m256 v = _mm256_set_ps(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8);
v = _mm256_hadd_ps(v, v);
v = _mm256_hadd_ps(v, v);
__m128 vlow = _mm256_castps256_ps128(v);
__m128 vhigh = _mm256_extractf128_ps(v, 1);
vlow = _mm_add_ps(vlow, vhigh);
float sum = vlow[0];
```